import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';

void main() => runApp(const RetroBudgetApp());

/// ====== ТЕМА + ДОДАТОК ======================================================
class RetroBudgetApp extends StatelessWidget {
  const RetroBudgetApp({super.key});

  @override
  Widget build(BuildContext context) {
    final base = ThemeData.dark(useMaterial3: true);
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      title: 'Ретро-бюджет',
      theme: base.copyWith(
        scaffoldBackgroundColor: const Color(0xFF0F1E17),
        colorScheme: base.colorScheme.copyWith(
          primary: const Color(0xFFFFC94A),
          secondary: const Color(0xFFFB8C0A),
        ),
        appBarTheme: base.appBarTheme.copyWith(
          backgroundColor: Colors.black,
          foregroundColor: Colors.white,
          titleTextStyle: const TextStyle(
            fontWeight: FontWeight.w700,
            fontSize: 22,
            color: Colors.white,
          ),
        ),
        floatingActionButtonTheme: const FloatingActionButtonThemeData(
          backgroundColor: Color(0xFFFFC94A),
          foregroundColor: Colors.black,
        ),
        listTileTheme: base.listTileTheme.copyWith(
          iconColor: const Color(0xFFFFC94A),
        ),
        cardTheme: base.cardTheme.copyWith(
          color: const Color(0xFF16241E),
          margin: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(16),
          ),
        ),
      ),
      home: const HomePage(),
    );
  }
}

/// ====== МОДЕЛІ ===============================================================
enum TxType { income, expense }

class Tx {
  final String id;
  double amount;
  String category;
  String note;
  DateTime date;
  TxType type;

  Tx({
    required this.id,
    required this.amount,
    required this.category,
    required this.note,
    required this.date,
    required this.type,
  });

  Map<String, dynamic> toJson() => {
        'id': id,
        'amount': amount,
        'category': category,
        'note': note,
        'date': date.toIso8601String(),
        'type': type.name,
      };

  static Tx fromJson(Map<String, dynamic> m) => Tx(
        id: m['id'] as String,
        amount: (m['amount'] as num).toDouble(),
        category: m['category'] as String,
        note: m['note'] as String? ?? '',
        date: DateTime.parse(m['date'] as String),
        type: (m['type'] as String) == 'income' ? TxType.income : TxType.expense,
      );
}

class AppStore extends ChangeNotifier {
  static const _kTxKey = 'tx_list_v1';
  static const _kCatsKey = 'cats_v1';
  static const _kBudgetKey = 'budget_v1';

  final List<Tx> _txs = [];
  final List<String> _categories = [
    'Продукти',
    'Транспорт',
    'Комуналка',
    'Кафе/розваги',
    'Здоровʼя',
    'Одяг',
    'Інше',
  ];
  double _monthlyBudget = 0;

  List<Tx> get txs => List.unmodifiable(_txs);
  List<String> get categories => List.unmodifiable(_categories);
  double get budget => _monthlyBudget;

  double get spent => _txs
      .where((t) => t.type == TxType.expense)
      .fold(0.0, (s, t) => s + t.amount);

  double get income =>
      _txs.where((t) => t.type == TxType.income).fold(0.0, (s, t) => s + t.amount);

  double get balance => income - spent;
  double get budgetLeft => _monthlyBudget - spent;

  Future<void> load() async {
    final sp = await SharedPreferences.getInstance();

    // Транзакції
    final raw = sp.getString(_kTxKey);
    if (raw != null && raw.isNotEmpty) {
      final list = (jsonDecode(raw) as List)
          .map((e) => Tx.fromJson(e as Map<String, dynamic>))
          .toList()
        ..sort((a, b) => b.date.compareTo(a.date));
      _txs
        ..clear()
        ..addAll(list);
    }

    // Категорії
    final rawCats = sp.getStringList(_kCatsKey);
    if (rawCats != null && rawCats.isNotEmpty) {
      _categories
        ..clear()
        ..addAll(rawCats);
    }

    // Бюджет
    _monthlyBudget = sp.getDouble(_kBudgetKey) ?? 0;

    notifyListeners();
  }

  Future<void> _persist() async {
    final sp = await SharedPreferences.getInstance();
    await sp.setString(
      _kTxKey,
      jsonEncode(_txs.map((e) => e.toJson()).toList()),
    );
    await sp.setStringList(_kCatsKey, _categories);
    await sp.setDouble(_kBudgetKey, _monthlyBudget);
  }

  Future<void> addTx(Tx tx) async {
    _txs.insert(0, tx);
    await _persist();
    notifyListeners();
  }

  Future<void> updateTx(Tx tx) async {
    final idx = _txs.indexWhere((t) => t.id == tx.id);
    if (idx != -1) {
      _txs[idx] = tx;
      await _persist();
      notifyListeners();
    }
  }

  Future<void> deleteTx(String id) async {
    _txs.removeWhere((t) => t.id == id);
    await _persist();
    notifyListeners();
  }

  Future<void> setBudget(double v) async {
    _monthlyBudget = v;
    await _persist();
    notifyListeners();
  }

  Future<void> addCategory(String name) async {
    if (name.trim().isEmpty) return;
    if (!_categories.contains(name)) {
      _categories.add(name);
      await _persist();
      notifyListeners();
    }
  }

  Future<void> renameCategory(String oldName, String newName) async {
    final idx = _categories.indexOf(oldName);
    if (idx == -1 || newName.trim().isEmpty) return;
    _categories[idx] = newName;
    // оновити транзакції цієї категорії
    for (final t in _txs) {
      if (t.category == oldName) t.category = newName;
    }
    await _persist();
    notifyListeners();
  }

  Future<void> removeCategory(String name) async {
    if (!_categories.contains(name)) return;
    _categories.remove(name);
    // транзакції залишаються з колишньою назвою (історія), або перенести в “Інше”
    for (final t in _txs) {
      if (t.category == name) t.category = 'Інше';
    }
    await _persist();
    notifyListeners();
  }
}

/// ====== ГОЛОВНА СТОРІНКА =====================================================
class HomePage extends StatefulWidget {
  const HomePage({super.key});

  @override
  State<HomePage> createState() => _HomePageState();
}

class _HomePageState extends State<HomePage> {
  final store = AppStore();

  @override
  void initState() {
    super.initState();
    store.addListener(_refresh);
    store.load();
  }

  @override
  void dispose() {
    store.removeListener(_refresh);
    super.dispose();
  }

  void _refresh() => setState(() {});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Розподіл коштів'),
        actions: [
          IconButton(
            tooltip: 'Бюджет',
            onPressed: () async {
              final v = await _askNumber(
                context: context,
                title: 'Місячний бюджет',
                initial: store.budget,
              );
              if (v != null) {
                await store.setBudget(v);
              }
            },
            icon: const Icon(Icons.account_balance_wallet_outlined),
          ),
          IconButton(
            tooltip: 'Категорії',
            onPressed: () => Navigator.of(context).push(
              MaterialPageRoute(builder: (_) => CategoriesPage(store: store)),
            ),
            icon: const Icon(Icons.category_outlined),
          ),
        ],
      ),
      floatingActionButton: FloatingActionButton.extended(
        onPressed: () => _openEditor(),
        label: const Text('Додати'),
        icon: const Icon(Icons.add),
      ),
      body: Column(
        children: [
          _Summary(store: store),
          const SizedBox(height: 4),
          Expanded(
            child: store.txs.isEmpty
                ? const Center(
                    child: Text(
                      'Тут поки порожньо.\nДодай першу транзакцію.',
                      textAlign: TextAlign.center,
                      style: TextStyle(fontSize: 16),
                    ),
                  )
                : ListView.builder(
                    itemCount: store.txs.length,
                    itemBuilder: (_, i) {
                      final t = store.txs[i];
                      final isExpense = t.type == TxType.expense;
                      return Card(
                        child: ListTile(
                          leading: CircleAvatar(
                            backgroundColor: isExpense
                                ? Colors.red.withOpacity(0.2)
                                : Colors.green.withOpacity(0.2),
                            child: Icon(
                              isExpense ? Icons.remove : Icons.add,
                              color: isExpense ? Colors.red : Colors.green,
                            ),
                          ),
                          title: Text(
                            t.category,
                            style: const TextStyle(fontWeight: FontWeight.w600),
                          ),
                          subtitle: Text(
                            '${_fmtDate(t.date)}  ${t.note.isEmpty ? '' : '• ${t.note}'}',
                          ),
                          trailing: Text(
                            (isExpense ? '-' : '+') + _money(t.amount),
                            style: TextStyle(
                              fontWeight: FontWeight.w700,
                              color: isExpense ? Colors.red : Colors.green,
                              fontSize: 16,
                            ),
                          ),
                          onTap: () => _openEditor(edit: t),
                          onLongPress: () async {
                            final ok = await _confirm(
                              context,
                              'Видалити транзакцію?',
                            );
                            if (ok == true) {
                              await store.deleteTx(t.id);
                            }
                          },
                        ),
                      );
                    },
                  ),
          ),
        ],
      ),
    );
  }

  Future<void> _openEditor({Tx? edit}) async {
    final res = await showModalBottomSheet<Tx>(
      context: context,
      isScrollControlled: true,
      builder: (_) => Padding(
        padding: EdgeInsets.only(
          bottom: MediaQuery.of(context).viewInsets.bottom,
        ),
        child: TxEditor(store: store, initial: edit),
      ),
    );

    if (res != null) {
      if (edit == null) {
        await store.addTx(res);
      } else {
        await store.updateTx(res);
      }
    }
  }
}

/// ====== ВІДЖЕТ ПІДСУМКІВ =====================================================
class _Summary extends StatelessWidget {
  const _Summary({required this.store});
  final AppStore store;

  @override
  Widget build(BuildContext context) {
    final chipStyle = Theme.of(context).textTheme.titleMedium;
    return Padding(
      padding: const EdgeInsets.fromLTRB(12, 12, 12, 6),
      child: Column(
        children: [
          Row(
            children: [
              Expanded(child: _StatCard(title: 'Бюджет', value: _money(store.budget))),
              Expanded(child: _StatCard(title: 'Витрачено', value: _money(store.spent))),
            ],
          ),
          Row(
            children: [
              Expanded(child: _StatCard(title: 'Баланс', value: _money(store.balance))),
              Expanded(child: _StatCard(title: 'Залишок бюджету', value: _money(store.budgetLeft))),
            ],
          ),
          const SizedBox(height: 2),
          Wrap(
            spacing: 8,
            runSpacing: 6,
            children: [
              Chip(
                label: Text('Доходи: ${_money(store.income)}', style: chipStyle),
                avatar: const Icon(Icons.trending_up, color: Colors.green),
                backgroundColor: Colors.green.withOpacity(0.15),
                side: BorderSide.none,
              ),
              Chip(
                label: Text('Витрати: ${_money(store.spent)}', style: chipStyle),
                avatar: const Icon(Icons.trending_down, color: Colors.red),
                backgroundColor: Colors.red.withOpacity(0.15),
                side: BorderSide.none,
              ),
            ],
          )
        ],
      ),
    );
  }
}

class _StatCard extends StatelessWidget {
  const _StatCard({required this.title, required this.value});
  final String title;
  final String value;

  @override
  Widget build(BuildContext context) {
    return Card(
      child: Container(
        padding: const EdgeInsets.all(14),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(title,
                style: const TextStyle(
                    fontSize: 14, color: Colors.white70, fontWeight: FontWeight.w500)),
            const SizedBox(height: 6),
            Text(
              value,
              style: const TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
            )
          ],
        ),
      ),
    );
  }
}

/// ====== ЕКРАН КАТЕГОРІЙ ======================================================
class CategoriesPage extends StatefulWidget {
  const CategoriesPage({super.key, required this.store});
  final AppStore store;

  @override
  State<CategoriesPage> createState() => _CategoriesPageState();
}

class _CategoriesPageState extends State<CategoriesPage> {
  @override
  Widget build(BuildContext context) {
    final store = widget.store;
    return Scaffold(
      appBar: AppBar(title: const Text('Категорії')),
      floatingActionButton: FloatingActionButton(
        onPressed: () async {
          final name = await _askText(context: context, title: 'Нова категорія');
          if (name != null) await store.addCategory(name);
          setState(() {});
        },
        child: const Icon(Icons.add),
      ),
      body: ListView.builder(
        itemCount: store.categories.length,
        itemBuilder: (_, i) {
          final c = store.categories[i];
          return Card(
            child: ListTile(
              title: Text(c),
              trailing: Wrap(
                children: [
                  IconButton(
                    tooltip: 'Перейменувати',
                    onPressed: () async {
                      final nn = await _askText(
                        context: context,
                        title: 'Перейменувати категорію',
                        initial: c,
                      );
                      if (nn != null) {
                        await store.renameCategory(c, nn);
                        setState(() {});
                      }
                    },
                    icon: const Icon(Icons.edit_outlined),
                  ),
                  IconButton(
                    tooltip: 'Видалити',
                    onPressed: () async {
                      final ok = await _confirm(context, 'Видалити "$c"?');
                      if (ok == true) {
                        await store.removeCategory(c);
                        setState(() {});
                      }
                    },
                    icon: const Icon(Icons.delete_outline, color: Colors.redAccent),
                  ),
                ],
              ),
            ),
          );
        },
      ),
    );
  }
}

/// ====== РЕДАКТОР ТРАНЗАКЦІЇ ==================================================
class TxEditor extends StatefulWidget {
  const TxEditor({super.key, required this.store, this.initial});
  final AppStore store;
  final Tx? initial;

  @override
  State<TxEditor> createState() => _TxEditorState();
}

class _TxEditorState extends State<TxEditor> {
  final _form = GlobalKey<FormState>();
  late bool _isExpense;
  late TextEditingController _amount;
  late TextEditingController _note;
  late DateTime _date;
  late String _category;

  @override
  void initState() {
    super.initState();
    final t = widget.initial;
    _isExpense = t == null ? true : t.type == TxType.expense;
    _amount = TextEditingController(text: t?.amount.toStringAsFixed(2) ?? '');
    _note = TextEditingController(text: t?.note ?? '');
    _date = t?.date ?? DateTime.now();
    _category = t?.category ?? widget.store.categories.first;
  }

  @override
  void dispose() {
    _amount.dispose();
    _note.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.fromLTRB(16, 16, 16, 24),
      child: Form(
        key: _form,
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Row(
              children: [
                ChoiceChip(
                  selected: !_isExpense,
                  label: const Text('Дохід'),
                  onSelected: (_) => setState(() => _isExpense = false),
                ),
                const SizedBox(width: 8),
                ChoiceChip(
                  selected: _isExpense,
                  label: const Text('Витрата'),
                  onSelected: (_) => setState(() => _isExpense = true),
                ),
                const Spacer(),
                TextButton.icon(
                  onPressed: () async {
                    final d = await showDatePicker(
                      context: context,
                      firstDate: DateTime(2020),
                      lastDate: DateTime(2100),
                      initialDate: _date,
                    );
                    if (d != null) setState(() => _date = d);
                  },
                  icon: const Icon(Icons.date_range),
                  label: Text(_fmtDate(_date)),
                ),
              ],
            ),
            const SizedBox(height: 8),
            DropdownButtonFormField<String>(
              value: _category,
              items: widget.store.categories
                  .map((c) => DropdownMenuItem(value: c, child: Text(c)))
                  .toList(),
              onChanged: (v) => setState(() => _category = v ?? _category),
              decoration: const InputDecoration(
                labelText: 'Категорія',
                border: OutlineInputBorder(),
              ),
            ),
            const SizedBox(height: 8),
            TextFormField(
              controller: _amount,
              keyboardType:
                  const TextInputType.numberWithOptions(decimal: true, signed: false),
              decoration: const InputDecoration(
                labelText: 'Сума',
                prefixText: '₴ ',
                border: OutlineInputBorder(),
              ),
              validator: (v) {
                final x = double.tryParse(v?.replaceAll(',', '.') ?? '');
                if (x == null || x <= 0) return 'Вкажи суму > 0';
                return null;
              },
            ),
            const SizedBox(height: 8),
            TextFormField(
              controller: _note,
              decoration: const InputDecoration(
                labelText: 'Нотатка (необовʼязково)',
                border: OutlineInputBorder(),
              ),
            ),
            const SizedBox(height: 12),
            SizedBox(
              width: double.infinity,
              child: FilledButton(
                onPressed: () {
                  if (!_form.currentState!.validate()) return;
                  final amount =
                      double.parse(_amount.text.replaceAll(',', '.')).abs();
                  final tx = Tx(
                    id: widget.initial?.id ?? DateTime.now().millisecondsSinceEpoch.toString(),
                    amount: amount,
                    category: _category,
                    note: _note.text.trim(),
                    date: _date,
                    type: _isExpense ? TxType.expense : TxType.income,
                  );
                  Navigator.pop(context, tx);
                },
                child: Text(widget.initial == null ? 'Додати' : 'Зберегти'),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

/// ====== ХЕЛПЕРИ ==============================================================
String _money(double v) => v.toStringAsFixed(2);
String _fmtDate(DateTime d) =>
    '${d.day.toString().padLeft(2, '0')}.${d.month.toString().padLeft(2, '0')}.${d.year}';

Future<bool?> _confirm(BuildContext ctx, String msg) async {
  return showDialog<bool>(
    context: ctx,
    builder: (_) => AlertDialog(
      title: const Text('Підтвердження'),
      content: Text(msg),
      actions: [
        TextButton(onPressed: () => Navigator.pop(ctx, false), child: const Text('Ні')),
        FilledButton(onPressed: () => Navigator.pop(ctx, true), child: const Text('Так')),
      ],
    ),
  );
}

Future<double?> _askNumber({
  required BuildContext context,
  required String title,
  double initial = 0,
}) async {
  final ctrl = TextEditingController(
      text: initial <= 0 ? '' : initial.toStringAsFixed(2));
  final form = GlobalKey<FormState>();
  return showDialog<double>(
    context: context,
    builder: (_) => AlertDialog(
      title: Text(title),
      content: Form(
        key: form,
        child: TextFormField(
          controller: ctrl,
          keyboardType:
              const TextInputType.numberWithOptions(decimal: true, signed: false),
          decoration: const InputDecoration(prefixText: '₴ ', labelText: 'Сума'),
          validator: (v) =>
              (double.tryParse(v?.replaceAll(',', '.') ?? '') ?? -1) >= 0
                  ? null
                  : 'Некоректне число',
        ),
      ),
      actions: [
        TextButton(onPressed: () => Navigator.pop(context), child: const Text('Скасувати')),
        FilledButton(
          onPressed: () {
            if (!form.currentState!.validate()) return;
            Navigator.pop(
                context, double.parse(ctrl.text.replaceAll(',', '.')).abs());
          },
          child: const Text('Зберегти'),
        ),
      ],
    ),
  );
}

Future<String?> _askText({
  required BuildContext context,
  required String title,
  String initial = '',
}) async {
  final ctrl = TextEditingController(text: initial);
  return showDialog<String>(
    context: context,
    builder: (_) => AlertDialog(
      title: Text(title),
      content: TextField(
        controller: ctrl,
        decoration: const InputDecoration(labelText: 'Назва'),
      ),
      actions: [
        TextButton(onPressed: () => Navigator.pop(context), child: const Text('Скасувати')),
        FilledButton(
          onPressed: () => Navigator.pop(context, ctrl.text.trim()),
          child: const Text('OK'),
        ),
      ],
    ),
  );
}
